"use client";

/**
 * Auto-generated by: https://github.com/pmndrs/gltfjsx
 * Command: npx gltfjsx@6.2.16 .\models\die2_optimised_renamed.glb --output .\src\app\_models\die.tsx --types --transform --debug
 */

import * as THREE from "three";
import React from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    edges: THREE.Mesh;
    faces: THREE.Mesh;
    nuts: THREE.Mesh;
  };
  materials: {
    ["edges BFDFED"]: THREE.MeshStandardMaterial;
    ["faces BFDFED"]: THREE.MeshStandardMaterial;
    ["nuts 59615C"]: THREE.MeshStandardMaterial;
  };
};

type ContextType = Record<
  string,
  React.ForwardRefExoticComponent<JSX.IntrinsicElements["mesh"]>
>;

const invertNormalMap = (material: THREE.MeshStandardMaterial) => {
  const image = material.normalMap?.image;
  if (!image) {
    throw new Error("Material does not have a normal map");
  }

  const width = image.width;
  const height = image.height;
  const canvas = new OffscreenCanvas(width, height);
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Could not get 2d context");
  }

  // Flip the image vertically
  ctx.save(); // Save the current state of the context
  ctx.translate(0, canvas.height); // Move the origin to the bottom-left corner
  ctx.scale(1, -1); // Scale vertically by -1 (flip vertically)
  ctx.drawImage(image, 0, 0, canvas.width, canvas.height); // Draw the image
  ctx.restore(); // Restore the context to its original state

  const imageData = ctx.getImageData(0, 0, width, height);
  const pixels = imageData.data;

  const bytesPerPixel = pixels.length / (width * height);
  if (bytesPerPixel !== 4) {
    throw new Error("Unexpected number of bytes per pixel");
  }

  for (let i = 0; i < pixels.length; i += 4) {
    pixels[i + 1] = 255 - pixels[i + 1];
  }

  ctx.putImageData(imageData, 0, 0);

  const normalMap = new THREE.CanvasTexture(canvas);
  normalMap.wrapS = THREE.RepeatWrapping;
  normalMap.wrapT = THREE.RepeatWrapping;
  normalMap.repeat.set(1, 1);

  return normalMap;
};

const applyColor = (
  material: THREE.MeshStandardMaterial,
  color: THREE.Color,
) => {
  const image = material.map?.image;
  if (!image) {
    throw new Error("Material does not have a map");
  }

  const width = image.width;
  const height = image.height;
  const canvas = new OffscreenCanvas(width, height);
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Could not get 2d context");
  }

  ctx.fillStyle = color.getStyle();
  ctx.fillRect(0, 0, width, height);

  // Flip the image vertically
  ctx.save(); // Save the current state of the context
  ctx.translate(0, canvas.height); // Move the origin to the bottom-left corner
  ctx.scale(1, -1); // Scale vertically by -1 (flip vertically)
  ctx.drawImage(image, 0, 0, canvas.width, canvas.height); // Draw the image
  ctx.restore(); // Restore the context to its original state

  // Debugging
  // canvas.convertToBlob().then((blob) => {
  //   const url = URL.createObjectURL(blob);
  //   const img = new Image();
  //   img.src = url;
  //   document.body.appendChild(img);
  // });

  // material.map = new THREE.CanvasTexture(canvas);
  // material.emissiveMap = null;
  // material.emissiveIntensity = 0;
  // material.roughnessMap = null;
  // material.metalnessMap = null;
  // material.normalMap = null;
  // material.color = color;

  const map = new THREE.CanvasTexture(canvas);
  map.wrapS = THREE.RepeatWrapping;
  map.wrapT = THREE.RepeatWrapping;
  map.repeat.set(1, 1);

  return new THREE.MeshStandardMaterial({
    map: map,
    normalMap: material.normalMap,
    normalMapType: THREE.TangentSpaceNormalMap,
    name: `${material.name} (colored)`,
    userData: {
      hasColorBeenApplied: true,
    },
  });
};

export function Die(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/models/die.glb") as GLTFResult;

  const startTime = new Date().getTime();

  for (const [name, material] of Object.entries(materials)) {
    if (material.userData.hasColorBeenApplied) {
      continue;
    }

    try {
      const color = new THREE.Color(`#${material.name.split(" ")[1]}`);
      const coloredMaterial = applyColor(material, color);
      try {
        if (material.normalMap) {
          coloredMaterial.normalMap = invertNormalMap(coloredMaterial);
        }
      } catch (error) {
        console.error(error);
      }

      materials[name as keyof typeof materials] = coloredMaterial;
    } catch (error) {
      console.error(error);
    }
  }

  console.log(
    "Time to render textures:",
    new Date().getTime() - startTime,
    "ms",
  );

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.edges.geometry}
        material={materials["edges BFDFED"]}
      />
      <mesh
        geometry={nodes.faces.geometry}
        material={materials["faces BFDFED"]}
      />
      <mesh
        geometry={nodes.nuts.geometry}
        material={materials["nuts 59615C"]}
      />
    </group>
  );
}

useGLTF.preload("/models/die.glb");
